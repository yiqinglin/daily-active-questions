import * as app from '~/app';
import GraphQLJSON from 'graphql-type-json';

export default {
  Query: {
    user(obj, args, context) {
      const { user } = context;

      return user;
    },
    async activeQuestions(obj, args, context) {
      const { user } = context;
      
      if (!user) {
        throw Error('Log in is required.');
      }

      // Get current date in millieseconds.      
      const nowTime = new Date();

      nowTime.setHours(0, 0, 0, 0);
      const todayBeginsAt = nowTime.getTime();
      const promises = [];
      const res = [];
      const questionIds = [];

      // Get active questions based on user id.
      const quesRef = await app.db
        .collection('questions')
        .where('userId', '==', user.id)
        .where('active', '>', 0)
        .get();
      
      // Get today's answers.
      const ansRef = await app.db
        .collection('answers')
        .where('userId', '==', user.id)
        .where('timestamp', '>=', todayBeginsAt)
        .get();

      quesRef.forEach(snapshot => {
        res.push(snapshot.data());
      });
      ansRef.forEach(snapshot => {
        const answers = snapshot.data().values;
        
        Object.keys(answers).map((qid) => {
          // Insert the answer value to res using questionId.
          const targetIndex = res.findIndex(item => item.id === qid);
          if (targetIndex > -1) {
            res.splice(targetIndex, 1, {
              ...res[targetIndex],
              answer: answers[qid]
            })
          }
        });
      });

      return res;
    }
  },
  Mutation: {
    async login() {
      return {};
    },
    async answer(obj, args, context) {
      const { user } = context;
      const { answers } = args;

      // Get current date in millieseconds.      
      const timestamp = new Date().getTime();

      if (!user) {
        throw Error('Log in is required.');
      }
      if (!answers) {
        throw Error('Required parameters not found.');
      }

      await app.db.collection('answers')
        .add({
          timestamp,
          values: answers,
          userId: user.id
        });

      return;
    },
    async addQuestion(obj, args, context) {
      const { user } = context;
      const { question } = args;

      if (!user) {
        throw Error('Log in is required.');
      }

      // Get the doc ref first to save the auto-ID generated by Firestore in the document.
      const docRef = await app.db.collection('questions').doc();
      await docRef.set({
          active: 1, // TODO: update this to ranking
          title: question,
          userId: user.id,
          id: docRef.id
        });

      return;
    },
    async updateQuestion(obj ,args, context) {
      const { user } = context;
      const { question, qid } = args;

      if (!user) {
        throw Error('Log in is required.');
      }

      const quesRef = await app.db.collection('questions').doc(qid).get();
       // Check if user is updating the question created by him/herself.
      const isAuthorized = quesRef.data().userId === user.id;
     
      if (!isAuthorized) {
        throw Error('You are not authorized to update this question.')
      }

      await app.db.collection('questions').doc(qid).set({ title: question }, {merge: true});
      return;
    },
    async deleteQuestion(obj, args, context) {
      const { user } = context;
      const { qid } = args;
  
      if (!user) {
        throw Error('Log in is required.');
      }
  
      await app.db.collection('questions').doc(qid).set({active: -1}, {merge: true});
  
      return;
    }
  },
  JSON: GraphQLJSON
};
